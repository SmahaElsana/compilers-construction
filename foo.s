;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 41

section .data
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_BOOL(0)
MAKE_BOOL(1)
;;6
MAKE_LITERAL_RATIONAL(-1,1)
;;23
MAKE_LITERAL_RATIONAL(0,1)
;;40
MAKE_LITERAL_RATIONAL(1,1)
;;57
MAKE_LITERAL_RATIONAL(2,1)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+ WORD_SIZE*0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+ WORD_SIZE*1], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+ WORD_SIZE*2], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+ WORD_SIZE*3], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+ WORD_SIZE*4], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+ WORD_SIZE*5], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+ WORD_SIZE*6], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+ WORD_SIZE*7], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+ WORD_SIZE*8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+ WORD_SIZE*9], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+ WORD_SIZE*10], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+ WORD_SIZE*11], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+ WORD_SIZE*12], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+ WORD_SIZE*13], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+ WORD_SIZE*14], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+ WORD_SIZE*15], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+ WORD_SIZE*16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+ WORD_SIZE*17], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+ WORD_SIZE*18], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+ WORD_SIZE*19], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+ WORD_SIZE*20], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+ WORD_SIZE*21], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+ WORD_SIZE*22], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+ WORD_SIZE*23], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+ WORD_SIZE*24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+ WORD_SIZE*25], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+ WORD_SIZE*26], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+ WORD_SIZE*27], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+ WORD_SIZE*28], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+ WORD_SIZE*29], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+ WORD_SIZE*30], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+ WORD_SIZE*31], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
;; THE INITIAL ENVIRONMENT IS EMPTY SO THERE IS NOTHING TO COPY
    mov rdx, SOB_NIL_ADDRESS
    ;;NOW WE TRY TO COPY PARAMS IF EXIST
    mov rcx,qword[rbp + 3 * WORD_SIZE] ;;rcx holds the number of params
    cmp rcx, 0
    je lCopyParamsEnd1 ;;---> NO PARAMS TO COPY JUMP TO END

    mov rax, qword[rbp + 3 * WORD_SIZE]
    shl rax, 3
  ;;NOW RAX HOLDS THE NUMBER OF BYTES WE WANT TO ALLOCATE
  ;; cmp rcx, 0
;; je lCopyParamsEnd1
    MALLOC rax, rax
;;MALLOC rax, WORD_SIZE * rcx ;;rax holds the address of the newly allocated array for params in extenv
    mov qword[rdx], rax

  lCopyParams1:
;;cmp rcx,0 
;;je lCopyParamsEnd1
    mov r10, PVAR(rcx - 1) 
    mov [rax+ 8*(rcx-1)], r10
    dec rcx
    cmp rcx,0
    jne lCopyParams1
;;jmp lCopyParams1
    
    lCopyParamsEnd1:
    MAKE_CLOSURE(rax, rdx, Lcode1)

    jmp Lcont1
Lcode1:

    push rbp
    mov rbp , rsp
    ;;IF HEEEEEEERE 
;; APPLIC IS HINAAAA 
mov rax, PVAR(2)

push rax

push 1
mov rax, qword [fvar_tbl + WORD_SIZE*4]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	
cmp rax, SOB_FALSE_ADDRESS
        je Lelse2
mov rax, PVAR(1)
jmp Lexit2
        Lelse2:
;; APPLIC IS HINAAAA 
mov rax, PVAR(2)

push rax

push 1
mov rax, qword [fvar_tbl + WORD_SIZE*28]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

push rax
;; APPLIC IS HINAAAA 
;; APPLIC IS HINAAAA 
mov rax, PVAR(2)

push rax

push 1
mov rax, qword [fvar_tbl + WORD_SIZE*26]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

push rax
mov rax, PVAR(1)

push rax

push 2
mov rax, PVAR(0)

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

push rax
mov rax, PVAR(0)

push rax
push 3
mov rax, qword [fvar_tbl + WORD_SIZE*32]
;;APPLICTP IS HINNAAA
 CLOSURE_ENV rbx, rax              ; rbx = rax -> env 

      push rbx 
     
      ;; why plus one  
      push qword [rbp + WORD_SIZE * 1] 
 ;push the old ret addr as a ret address for h
   
      
  
    ;; mov r8, PVAR(-1)                   ; r8 = n (= PVAR(-1) = old args num)
    mov r8, [rbp + 3*WORD_SIZE]  
    ;; r8 holds the number of params of the A frame
    add r8, 3                       
    ;; r8 holds the size of the A frame --> number of params + the lexenv + #params pushed + return addr
    shl r8, 3                       
    ;;multiplied by 8 SO -->r8 now holds the number of bytes held by the A frame
    add r8, rbp                     
    ;;now r8 points to the last param(An-1) of the A frame

    mov rbp, PVAR(-4)                ; rbp points to old rbp
    ;;above line same as mov rbp, [rbp]

    mov rcx, [rsp + WORD_SIZE * 2]   
    ;; RCX HOLDS THE NUMBER OF ARGS IN THE B FRAME = List.length lst_str 
    add rcx, 3                       
    ;;rcx now holds the size of the new B frame --> M+3 -> #ARGS + LEX + RET-ADDR
    
    overwrite_frame3:
    
    mov r13, qword [rsp + WORD_SIZE * (rcx - 1)]
    mov r13, qword [rsp + WORD_SIZE * (rcx +1 -2)]
    mov [r8], qword r13
    ;;SINCE WE CANT COPY FROM ONE MEMORY ADDRESS TO ANOTHER WE USE THE R13 REGISTER AS AN AUXILARY MEMORY STORAGE

    sub r8, WORD_SIZE
    ;;WE SUB BY WORDS_SIZE SINCE R8 IS IN BYTES
    ;;now we move to the next cell of the stack
    dec rcx
    cmp rcx,0
    jne overwrite_frame3
  
    add r8, WORD_SIZE               
    ;; R8 HOLDS THE RETURN ADDRESS TO F 
    mov rsp, r8    
    ;;NOW WE HAVE UPDATED THE RSP -> STACK POINTER                

    ;;NOW JUMP TO CODE OF CLOSURE
    CLOSURE_CODE rax, rax            ; rax = rax -> code
    jmp rax
 
Lexit2:

    leave
    ret
  Lcont1:
mov qword[fvar_tbl + WORD_SIZE*32] , rax
    mov rax,SOB_VOID_ADDRESS

	call write_sob_if_not_void

;; THE INITIAL ENVIRONMENT IS EMPTY SO THERE IS NOTHING TO COPY
    mov rdx, SOB_NIL_ADDRESS
    ;;NOW WE TRY TO COPY PARAMS IF EXIST
    mov rcx,qword[rbp + 3 * WORD_SIZE] ;;rcx holds the number of params
    cmp rcx, 0
    je lCopyParamsEnd4 ;;---> NO PARAMS TO COPY JUMP TO END

    mov rax, qword[rbp + 3 * WORD_SIZE]
    shl rax, 3
  ;;NOW RAX HOLDS THE NUMBER OF BYTES WE WANT TO ALLOCATE
  ;; cmp rcx, 0
;; je lCopyParamsEnd4
    MALLOC rax, rax
;;MALLOC rax, WORD_SIZE * rcx ;;rax holds the address of the newly allocated array for params in extenv
    mov qword[rdx], rax

  lCopyParams4:
;;cmp rcx,0 
;;je lCopyParamsEnd4
    mov r10, PVAR(rcx - 1) 
    mov [rax+ 8*(rcx-1)], r10
    dec rcx
    cmp rcx,0
    jne lCopyParams4
;;jmp lCopyParams4
    
    lCopyParamsEnd4:
    MAKE_CLOSURE(rax, rdx, Lcode4)

    jmp Lcont4
Lcode4:

    push rbp
    mov rbp , rsp
    ;;IF HEEEEEEERE 
;; APPLIC IS HINAAAA 
mov rax, PVAR(2)

push rax

push 1
mov rax, qword [fvar_tbl + WORD_SIZE*4]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	
cmp rax, SOB_FALSE_ADDRESS
        je Lelse5
mov rax, PVAR(1)
jmp Lexit5
        Lelse5:
;; APPLIC IS HINAAAA 
;; APPLIC IS HINAAAA 
mov rax, PVAR(2)

push rax

push 1
mov rax, qword [fvar_tbl + WORD_SIZE*28]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

push rax
mov rax, PVAR(1)

push rax
mov rax, PVAR(0)

push rax

push 3
mov rax, qword [fvar_tbl + WORD_SIZE*33]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

push rax
;; APPLIC IS HINAAAA 
mov rax, PVAR(2)

push rax

push 1
mov rax, qword [fvar_tbl + WORD_SIZE*26]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

push rax
push 2
mov rax, PVAR(0)
;;APPLICTP IS HINNAAA
 CLOSURE_ENV rbx, rax              ; rbx = rax -> env 

      push rbx 
     
      ;; why plus one  
      push qword [rbp + WORD_SIZE * 1] 
 ;push the old ret addr as a ret address for h
   
      
  
    ;; mov r8, PVAR(-1)                   ; r8 = n (= PVAR(-1) = old args num)
    mov r8, [rbp + 3*WORD_SIZE]  
    ;; r8 holds the number of params of the A frame
    add r8, 3                       
    ;; r8 holds the size of the A frame --> number of params + the lexenv + #params pushed + return addr
    shl r8, 3                       
    ;;multiplied by 8 SO -->r8 now holds the number of bytes held by the A frame
    add r8, rbp                     
    ;;now r8 points to the last param(An-1) of the A frame

    mov rbp, PVAR(-4)                ; rbp points to old rbp
    ;;above line same as mov rbp, [rbp]

    mov rcx, [rsp + WORD_SIZE * 2]   
    ;; RCX HOLDS THE NUMBER OF ARGS IN THE B FRAME = List.length lst_str 
    add rcx, 3                       
    ;;rcx now holds the size of the new B frame --> M+3 -> #ARGS + LEX + RET-ADDR
    
    overwrite_frame6:
    
    mov r13, qword [rsp + WORD_SIZE * (rcx - 1)]
    mov r13, qword [rsp + WORD_SIZE * (rcx +1 -2)]
    mov [r8], qword r13
    ;;SINCE WE CANT COPY FROM ONE MEMORY ADDRESS TO ANOTHER WE USE THE R13 REGISTER AS AN AUXILARY MEMORY STORAGE

    sub r8, WORD_SIZE
    ;;WE SUB BY WORDS_SIZE SINCE R8 IS IN BYTES
    ;;now we move to the next cell of the stack
    dec rcx
    cmp rcx,0
    jne overwrite_frame6
  
    add r8, WORD_SIZE               
    ;; R8 HOLDS THE RETURN ADDRESS TO F 
    mov rsp, r8    
    ;;NOW WE HAVE UPDATED THE RSP -> STACK POINTER                

    ;;NOW JUMP TO CODE OF CLOSURE
    CLOSURE_CODE rax, rax            ; rax = rax -> code
    jmp rax
 
Lexit5:

    leave
    ret
  Lcont4:
mov qword[fvar_tbl + WORD_SIZE*33] , rax
    mov rax,SOB_VOID_ADDRESS

	call write_sob_if_not_void

;;LAMBDA OPT IS HINNA
        mov rdx, SOB_NIL_ADDRESS
        mov rcx, 0 
        cmp rcx, 0


createClosure7:


    
      MAKE_CLOSURE (rax, rdx,  Lcode7 )
        jmp Lcont7 
Lcode7:

      
        ;;ADJUST STACK HERE****************************************************************
        mov r15, qword [rsp + WORD_SIZE * 2]                    
        ;; r15 = the number of arguments on the stack sum of opt and non opt args
        mov r14, 0   
        ;; r14 = |str_lst| the number of non opt params
        cmp r15, r14
        ;; IF THE |OPT ARGS|=0 THEN R14=R15 --> NO NEED TO SHRINK THE STACK --> SHIFT THE SACK & CREATE EMPTY LIST
        jne  shrinkstack7
sub rsp, WORD_SIZE  
        	 ;; Create space for the params list BY shiftING THE stack
	
mov rcx, 0  
      mov rdx, 3 
      
        ;; RDX HOLDS THE FOLLOWING |arg| + WORD(holds #args)+ WORD(holds lex-env) + WORD(holds ret-addr)
      
	
;;HERE WE SHIFT DOWN THE STACK SINCE THE MANDATORY ARGS EQUAL THE NUMBER OF ARGS ON THE STACK	
;; THE NUMBER OF OPT ARGS HERE IS 0 --> WE CREATE AN EMPTY LIST AND ADD IT TO THE STACK	

shiftdown7 :
      ;;HERE WE SHIFT DOWN THE STACK IN ORDER TO CREATE SPACE FOR THE OPT LIST
        mov r8, [rsp + WORD_SIZE * (rcx + 1)]
        mov [rsp + WORD_SIZE * rcx], r8
        inc rcx
    
    cmp rcx, rdx
        ;;MOVING TO THE NEXT WORD ON THE STACK --->PARAMS/ LEX / RET-ADDRESS / #ARGS
        jne shiftdown7

 mov qword [rsp + WORD_SIZE * rcx], SOB_NIL_ADDRESS 
  
      ;; NOW WE add the empty list
    
      inc r14
      mov [rsp + WORD_SIZE * 2], r14
      jmp doneadjust7
      
    ;;SHRINK STACK -> THERE ARE OPT ARGS


	 ;;WE SHRINK THE STACK #OPTARGS-1 BECUASE WE TAKE THE OPT ARGS AND PUT THEM IN A LIST AND PUT THE LIST ON TOP 
	
shrinkstack7:
    ;; R15 --> THE NUMBER OF ARGS ON THE STACK --> OPT + NON-OPT
    ;; R14 --> STR-LST THE NUMBER OF MANDATORY(NON OPT) ARGUMENTS
      
    mov rdx, r15 
                
    sub rdx, r14 

    mov rcx, rdx  
	
               
      ;; RCX NOW CONTAINS THE NUMBER OF OPT-ARGS
    
    
      mov r9, SOB_NIL_ADDRESS       
    ;; r9 point to an empty list
;;MAKE THE LAST CDR OF THE LIST NIL 
	
createList7:
      ;;RCX HOLDS COUNTER	


      mov r11, r14
        add r11, rcx                  
        mov r8, [rsp + WORD_SIZE * (2 + r11)]
        MAKE_PAIR(rax, r8, r9)
      ;;AT THIS POINT RAX HOLDS A POINTER TO THE CREATED PAIR
        mov r9, rax
      ;;WE MOVE RAX TO R9 IN ORDER TO CONTINUE RECURSIVLY
        dec rcx
        cmp rcx, 0
        jne createList7
      
    
        
      ;;SHRINK THE STACK HERE
      mov rax, 2
      add rax, r15          
      ;;R15 --> THE NUMBER OF ARGS ON THE STACK --> OPT + NON-OPT ---> RAX = THE NUMBER OF ARGS ON THE STACK               
      
      
      mov qword [rsp + WORD_SIZE * rax], r9   
      ;;NOW THE TOP OF THE FRAME POINTS TO THE OPT ARGS LIST
    
      mov rcx, rax
      dec rcx
      mov r11, r14     
      ;;R14 HOLDS THE #MANDATORY PARAMS --> R11 HOLDS THE #MANDATORY PARAMS 
      add r11, 2       
      ;;ALSO SHIFT THE RETURN ADDRESS AND LEXENV AND THE ARGS COUNT 
	
shiftup7:
	

      ;;WE SHIFT UP THE STACK IN ORDER TO REMOVE THE THE OPT ARGS FROM THE STACK AND ADD THEM AS A LIST 
      mov r8, qword [rsp + WORD_SIZE * r11]
      mov [rsp + WORD_SIZE * rcx], r8
      ;;SINCE WE CANT MOVE FROM ONE MEMORY ADDRESS TO ANOTHER MEMORY ADDRESS, WE MUST USE AN AUXILARY REGISTER
      dec rcx
      dec r11
      ;;DECREMENT BOTH POINTERS, WHERE WE READ FROM AND WHERE WE WRITE TO 
      cmp r11, 0
      jge  shiftup7
	
 
    
    
    
    ;;RDX HOLDS THE NUMBER OF OPT ARGUMENTS
    dec rdx
    ;;RDX IS DECREMENTED CUZ WE WANT DONT WANT TO REMOVE THE LIST WE ADDED
    shl rdx, 3
      ;; MUL BY 8 = SHIFT 3, TO GET THE NUMBER OF BYTES IN ORDER TO ADD TO RSP POINTER
    
    
      add rsp, rdx   
    ;; NOW WE FIX THE STACK POINTER 
    ;; NOW THE STACK CONTAINS THE OPT-ARGS AS A LIST
      mov qword [rsp + WORD_SIZE * 2], 1	
 ;;NUMBER OF ARGUMENTS ON THE STACK IS UPDATED BECAUSE OF THE OPT ARG
    
    ;;DONE SHRINKING STACK & ADJUST *********************************************************
doneadjust7:

    ;;AT THIS POINT WE FINISHED ADJUSTING THE STACK ACCORDING TO THE OPT PARAMS	
	

        push rbp

        mov rbp, rsp
mov rax, PVAR(0)


        leave

        ret
Lcont7:
	
mov qword[fvar_tbl + WORD_SIZE*35] , rax
    mov rax,SOB_VOID_ADDRESS

	call write_sob_if_not_void

;; THE INITIAL ENVIRONMENT IS EMPTY SO THERE IS NOTHING TO COPY
    mov rdx, SOB_NIL_ADDRESS
    ;;NOW WE TRY TO COPY PARAMS IF EXIST
    mov rcx,qword[rbp + 3 * WORD_SIZE] ;;rcx holds the number of params
    cmp rcx, 0
    je lCopyParamsEnd8 ;;---> NO PARAMS TO COPY JUMP TO END

    mov rax, qword[rbp + 3 * WORD_SIZE]
    shl rax, 3
  ;;NOW RAX HOLDS THE NUMBER OF BYTES WE WANT TO ALLOCATE
  ;; cmp rcx, 0
;; je lCopyParamsEnd8
    MALLOC rax, rax
;;MALLOC rax, WORD_SIZE * rcx ;;rax holds the address of the newly allocated array for params in extenv
    mov qword[rdx], rax

  lCopyParams8:
;;cmp rcx,0 
;;je lCopyParamsEnd8
    mov r10, PVAR(rcx - 1) 
    mov [rax+ 8*(rcx-1)], r10
    dec rcx
    cmp rcx,0
    jne lCopyParams8
;;jmp lCopyParams8
    
    lCopyParamsEnd8:
    MAKE_CLOSURE(rax, rdx, Lcode8)

    jmp Lcont8
Lcode8:

    push rbp
    mov rbp , rsp
    ;;IF HEEEEEEERE 
mov rax, PVAR(0)
cmp rax, SOB_FALSE_ADDRESS
        je Lelse9
  mov rax, const_tbl +2
jmp Lexit9
        Lelse9:
  mov rax, const_tbl +4

Lexit9:

    leave
    ret
  Lcont8:
mov qword[fvar_tbl + WORD_SIZE*36] , rax
    mov rax,SOB_VOID_ADDRESS

	call write_sob_if_not_void

;; APPLIC IS HINAAAA 
mov rax, qword [fvar_tbl + WORD_SIZE*4]

push rax
mov rax, qword [fvar_tbl + WORD_SIZE*18]

push rax
mov rax, qword [fvar_tbl + WORD_SIZE*31]

push rax

push 3
;; THE INITIAL ENVIRONMENT IS EMPTY SO THERE IS NOTHING TO COPY
    mov rdx, SOB_NIL_ADDRESS
    ;;NOW WE TRY TO COPY PARAMS IF EXIST
    mov rcx,qword[rbp + 3 * WORD_SIZE] ;;rcx holds the number of params
    cmp rcx, 0
    je lCopyParamsEnd10 ;;---> NO PARAMS TO COPY JUMP TO END

    mov rax, qword[rbp + 3 * WORD_SIZE]
    shl rax, 3
  ;;NOW RAX HOLDS THE NUMBER OF BYTES WE WANT TO ALLOCATE
  ;; cmp rcx, 0
;; je lCopyParamsEnd10
    MALLOC rax, rax
;;MALLOC rax, WORD_SIZE * rcx ;;rax holds the address of the newly allocated array for params in extenv
    mov qword[rdx], rax

  lCopyParams10:
;;cmp rcx,0 
;;je lCopyParamsEnd10
    mov r10, PVAR(rcx - 1) 
    mov [rax+ 8*(rcx-1)], r10
    dec rcx
    cmp rcx,0
    jne lCopyParams10
;;jmp lCopyParams10
    
    lCopyParamsEnd10:
    MAKE_CLOSURE(rax, rdx, Lcode10)

    jmp Lcont10
Lcode10:

    push rbp
    mov rbp , rsp
    ;;LAMBDA OPT IS HINNA
      mov rdx, SOB_NIL_ADDRESS
      mov rcx, 1 
      cmp rcx, 0
      je createClosure11
    ;;create space to store the extended enviorment
  
      MALLOC rdx, WORD_SIZE *2 
  ;;RDX HOLDS THE ADDRESS OF EXT ENV
    
                                          
    mov r10,qword [rbp+2*WORD_SIZE] 
;;THE ABOVE LINE IS SAME IS PVAR WITH -2
  
    copyEnv11:         
  mov r8, qword [r10 + WORD_SIZE * (rcx - 1)] 
  mov qword [rdx + WORD_SIZE * rcx], r8              
      cmp rcx,0
      jnz copyEnv11 

    
  
  mov r10, PVAR(-1)                
;; PVAR(-1) is the #arguments
  cmp r10,0
  je createClosure11
  
  
  ;;create a list where we will store the params
  shl r10, 3                    
  MALLOC r10, r10              
  ;;connect  the list to the extended environment
  mov qword [rdx], r10
  
    
    mov rcx, PVAR(-1)                 
  ;; PVAR(-1) is the #arguments
  
   addParams2lst11:
      mov r8, PVAR(rcx - 1) 
      ;;RCX IS OOUR INDEX OF THE ITH PARAM ON THE STACK WE ARE CURRENTLY COPYING 
	
                
      mov [r10 + WORD_SIZE * (rcx - 1)], r8
      dec rcx
      cmp rcx, 0
      jnz addParams2lst11

createClosure11:


    ;; NOW WE CREATE THE CLOSURE WITH THE RDX AS A POINTER TO EXT-ENV AND THE LCODE LABEL-> START OF CODE
	

    MAKE_CLOSURE (rax, rdx,  Lcode11 )
      jmp Lcont11 

Lcode11:

    
      ;;ADJUST STACK HERE****************************************************************
      mov r15, qword [rsp + WORD_SIZE * 2]                    
      ;; r15 = the number of arguments on the stack sum of opt and non opt args
      mov r14, 1   
      ;; r14 = |str_lst| the number of non opt params
      cmp r15, r14
      ;; IF THE |OPT ARGS|=0 THEN R14=R15 --> NO NEED TO SHRINK THE STACK --> SHIFT THE SACK & CREATE EMPTY LIST
      jne  shrinkstack11
sub rsp, WORD_SIZE  
      	 ;; Create space for the params list BY shiftING THE stack
	
mov rcx, 0  
    mov rdx, 4 
      
      ;; RDX HOLDS THE FOLLOWING |arg| + WORD(holds #args)+ WORD(holds lex-env) + WORD(holds ret-addr)
    
	
;;HERE WE SHIFT DOWN THE STACK SINCE THE MANDATORY ARGS EQUAL THE NUMBER OF ARGS ON THE STACK	
;; THE NUMBER OF OPT ARGS HERE IS 0 --> WE CREATE AN EMPTY LIST AND ADD IT TO THE STACK	

shiftdown11 :
    ;;HERE WE SHIFT DOWN THE STACK IN ORDER TO CREATE SPACE FOR THE OPT LIST
      mov r8, [rsp + WORD_SIZE * (rcx + 1)]
      mov [rsp + WORD_SIZE * rcx], r8
      inc rcx
  
  cmp rcx, rdx
      ;;MOVING TO THE NEXT WORD ON THE STACK --->PARAMS/ LEX / RET-ADDRESS / #ARGS
      jne shiftdown11

 mov qword [rsp + WORD_SIZE * rcx], SOB_NIL_ADDRESS 
  
    ;; NOW WE add the empty list
  
    inc r14
    mov [rsp + WORD_SIZE * 2], r14
    jmp doneadjust11
    
  ;;SHRINK STACK -> THERE ARE OPT ARGS


	 ;;WE SHRINK THE STACK #OPTARGS-1 BECUASE WE TAKE THE OPT ARGS AND PUT THEM IN A LIST AND PUT THE LIST ON TOP 
	
shrinkstack11:
  ;; R15 --> THE NUMBER OF ARGS ON THE STACK --> OPT + NON-OPT
  ;; R14 --> STR-LST THE NUMBER OF MANDATORY(NON OPT) ARGUMENTS
    
  mov rdx, r15 
                
  sub rdx, r14 

  mov rcx, rdx  
	
               
    ;; RCX NOW CONTAINS THE NUMBER OF OPT-ARGS
  
  
    mov r9, SOB_NIL_ADDRESS       
  ;; r9 point to an empty list
;;MAKE THE LAST CDR OF THE LIST NIL 
	
createList11:
    ;;RCX HOLDS COUNTER	


    mov r11, r14
      add r11, rcx                  
  ;; R11 HOLDS THE NUMBER OF ARGS ON THE STACK
      mov r8, [rsp + WORD_SIZE * (2 + r11)]
      MAKE_PAIR(rax, r8, r9)
      ;;RAX HOOLDS THE POINTER TO THE NEWLY CREATED PAIR
      mov r9, rax
    ;;WE MOVE RAX TO R9 IN ORDER TO CONTINUE RECURSIVLY
      dec rcx
      cmp rcx, 0
      jne createList11
    
  
      
    ;;SHRINK THE STACK HERE
    mov rax, 2
    add rax, r15          
    ;;R15 --> THE NUMBER OF ARGS ON THE STACK --> OPT + NON-OPT ---> RAX = THE NUMBER OF ARGS ON THE STACK               
    
    
    mov qword [rsp + WORD_SIZE * rax], r9   
    ;;NOW THE TOP OF THE FRAME POINTS TO THE OPT ARGS LIST
  
    mov rcx, rax
    dec rcx
    mov r11, r14     
    ;;R14 HOLDS THE #MANDATORY PARAMS --> R11 HOLDS THE #MANDATORY PARAMS 
    add r11, 2       
    ;;ALSO SHIFT THE RETURN ADDRESS AND LEXENV AND THE ARGS COUNT 
	
shiftup11:
	

    ;;WE SHIFT UP THE STACK IN ORDER TO REMOVE THE THE OPT ARGS FROM THE STACK AND ADD THEM AS A LIST 
    mov r8, qword [rsp + WORD_SIZE * r11]
    mov [rsp + WORD_SIZE * rcx], r8
    ;;SINCE WE CANT MOVE FROM ONE MEMORY ADDRESS TO ANOTHER MEMORY ADDRESS, WE MUST USE AN AUXILARY REGISTER
    dec rcx
    dec r11
    ;;DECREMENT BOTH POINTERS, WHERE WE READ FROM AND WHERE WE WRITE TO 
    cmp r11, 0
    jge  shiftup11
	
 
  
  
  
  ;;RDX HOLDS THE NUMBER OF OPT ARGUMENTS
  dec rdx
  ;;RDX IS DECREMENTED CUZ WE WANT DONT WANT TO REMOVE THE LIST WE ADDED
  shl rdx, 3
    ;; MUL BY 8 = SHIFT 3, TO GET THE NUMBER OF BYTES IN ORDER TO ADD TO RSP POINTER
  
  
    add rsp, rdx   
  ;; NOW WE FIX THE STACK POINTER 
  ;; NOW THE STACK CONTAINS THE OPT-ARGS AS A LIST
    mov qword [rsp + WORD_SIZE * 2], 2	
 ;;NUMBER OF ARGUMENTS ON THE STACK IS UPDATED BECAUSE OF THE OPT ARG
  
  ;;DONE SHRINKING STACK & ADJUST *********************************************************
doneadjust11:

  ;;AT THIS POINT WE FINISHED ADJUSTING THE STACK ACCORDING TO THE OPT PARAMS	
	

      push rbp

      mov rbp, rsp
;;IF HEEEEEEERE 
;; APPLIC IS HINAAAA 
mov rax, PVAR(1)

push rax

push 1

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*2]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	
cmp rax, SOB_FALSE_ADDRESS
        je Lelse12
;; APPLIC IS HINAAAA 
mov rax, PVAR(0)

push rax
  mov rax, const_tbl +6

push rax

push 2
mov rax, qword [fvar_tbl + WORD_SIZE*19]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

push rax
  mov rax, const_tbl +23

push rax
push 2

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*1]
;;APPLICTP IS HINNAAA
 CLOSURE_ENV rbx, rax              ; rbx = rax -> env 

      push rbx 
     
      ;; why plus one  
      push qword [rbp + WORD_SIZE * 1] 
 ;push the old ret addr as a ret address for h
   
      
  
    ;; mov r8, PVAR(-1)                   ; r8 = n (= PVAR(-1) = old args num)
    mov r8, [rbp + 3*WORD_SIZE]  
    ;; r8 holds the number of params of the A frame
    add r8, 3                       
    ;; r8 holds the size of the A frame --> number of params + the lexenv + #params pushed + return addr
    shl r8, 3                       
    ;;multiplied by 8 SO -->r8 now holds the number of bytes held by the A frame
    add r8, rbp                     
    ;;now r8 points to the last param(An-1) of the A frame

    mov rbp, PVAR(-4)                ; rbp points to old rbp
    ;;above line same as mov rbp, [rbp]

    mov rcx, [rsp + WORD_SIZE * 2]   
    ;; RCX HOLDS THE NUMBER OF ARGS IN THE B FRAME = List.length lst_str 
    add rcx, 3                       
    ;;rcx now holds the size of the new B frame --> M+3 -> #ARGS + LEX + RET-ADDR
    
    overwrite_frame14:
    
    mov r13, qword [rsp + WORD_SIZE * (rcx - 1)]
    mov r13, qword [rsp + WORD_SIZE * (rcx +1 -2)]
    mov [r8], qword r13
    ;;SINCE WE CANT COPY FROM ONE MEMORY ADDRESS TO ANOTHER WE USE THE R13 REGISTER AS AN AUXILARY MEMORY STORAGE

    sub r8, WORD_SIZE
    ;;WE SUB BY WORDS_SIZE SINCE R8 IS IN BYTES
    ;;now we move to the next cell of the stack
    dec rcx
    cmp rcx,0
    jne overwrite_frame14
  
    add r8, WORD_SIZE               
    ;; R8 HOLDS THE RETURN ADDRESS TO F 
    mov rsp, r8    
    ;;NOW WE HAVE UPDATED THE RSP -> STACK POINTER                

    ;;NOW JUMP TO CODE OF CLOSURE
    CLOSURE_CODE rax, rax            ; rax = rax -> code
    jmp rax
 jmp Lexit12
        Lelse12:
;; APPLIC IS HINAAAA 
;; APPLIC IS HINAAAA 
mov rax, PVAR(1)

push rax

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*1]

push rax

push 2

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*0]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

push rax
  mov rax, const_tbl +6

push rax

push 2
mov rax, qword [fvar_tbl + WORD_SIZE*19]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

push rax
mov rax, PVAR(0)

push rax
push 2

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*1]
;;APPLICTP IS HINNAAA
 CLOSURE_ENV rbx, rax              ; rbx = rax -> env 

      push rbx 
     
      ;; why plus one  
      push qword [rbp + WORD_SIZE * 1] 
 ;push the old ret addr as a ret address for h
   
      
  
    ;; mov r8, PVAR(-1)                   ; r8 = n (= PVAR(-1) = old args num)
    mov r8, [rbp + 3*WORD_SIZE]  
    ;; r8 holds the number of params of the A frame
    add r8, 3                       
    ;; r8 holds the size of the A frame --> number of params + the lexenv + #params pushed + return addr
    shl r8, 3                       
    ;;multiplied by 8 SO -->r8 now holds the number of bytes held by the A frame
    add r8, rbp                     
    ;;now r8 points to the last param(An-1) of the A frame

    mov rbp, PVAR(-4)                ; rbp points to old rbp
    ;;above line same as mov rbp, [rbp]

    mov rcx, [rsp + WORD_SIZE * 2]   
    ;; RCX HOLDS THE NUMBER OF ARGS IN THE B FRAME = List.length lst_str 
    add rcx, 3                       
    ;;rcx now holds the size of the new B frame --> M+3 -> #ARGS + LEX + RET-ADDR
    
    overwrite_frame13:
    
    mov r13, qword [rsp + WORD_SIZE * (rcx - 1)]
    mov r13, qword [rsp + WORD_SIZE * (rcx +1 -2)]
    mov [r8], qword r13
    ;;SINCE WE CANT COPY FROM ONE MEMORY ADDRESS TO ANOTHER WE USE THE R13 REGISTER AS AN AUXILARY MEMORY STORAGE

    sub r8, WORD_SIZE
    ;;WE SUB BY WORDS_SIZE SINCE R8 IS IN BYTES
    ;;now we move to the next cell of the stack
    dec rcx
    cmp rcx,0
    jne overwrite_frame13
  
    add r8, WORD_SIZE               
    ;; R8 HOLDS THE RETURN ADDRESS TO F 
    mov rsp, r8    
    ;;NOW WE HAVE UPDATED THE RSP -> STACK POINTER                

    ;;NOW JUMP TO CODE OF CLOSURE
    CLOSURE_CODE rax, rax            ; rax = rax -> code
    jmp rax
 
Lexit12:


      leave

      ret
Lcont11:
	

    leave
    ret
  Lcont10:

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	
mov qword[fvar_tbl + WORD_SIZE*37] , rax
    mov rax,SOB_VOID_ADDRESS

	call write_sob_if_not_void

;; APPLIC IS HINAAAA 
mov rax, qword [fvar_tbl + WORD_SIZE*21]

push rax

push 1
;; THE INITIAL ENVIRONMENT IS EMPTY SO THERE IS NOTHING TO COPY
    mov rdx, SOB_NIL_ADDRESS
    ;;NOW WE TRY TO COPY PARAMS IF EXIST
    mov rcx,qword[rbp + 3 * WORD_SIZE] ;;rcx holds the number of params
    cmp rcx, 0
    je lCopyParamsEnd15 ;;---> NO PARAMS TO COPY JUMP TO END

    mov rax, qword[rbp + 3 * WORD_SIZE]
    shl rax, 3
  ;;NOW RAX HOLDS THE NUMBER OF BYTES WE WANT TO ALLOCATE
  ;; cmp rcx, 0
;; je lCopyParamsEnd15
    MALLOC rax, rax
;;MALLOC rax, WORD_SIZE * rcx ;;rax holds the address of the newly allocated array for params in extenv
    mov qword[rdx], rax

  lCopyParams15:
;;cmp rcx,0 
;;je lCopyParamsEnd15
    mov r10, PVAR(rcx - 1) 
    mov [rax+ 8*(rcx-1)], r10
    dec rcx
    cmp rcx,0
    jne lCopyParams15
;;jmp lCopyParams15
    
    lCopyParamsEnd15:
    MAKE_CLOSURE(rax, rdx, Lcode15)

    jmp Lcont15
Lcode15:

    push rbp
    mov rbp , rsp
    ;;LAMBDA IS HIIINA

  ;;mov rdx, SOB_NIL_ADDRESS
;; mov rcx,1
;;cmp rcx , 0
;;je lambdaEnvEnd16

      mov rcx,1
      MALLOC rdx , WORD_SIZE * 2 ;;rdx points to extended env
      mov rbx, qword[rbp + WORD_SIZE*2] ;;point to lex env
    lambdaEnv16:
;;cmp rcx, 0
;; je lambdaEnvEnd16
      mov r10, qword[rbx + WORD_SIZE*(rcx-1)]
      mov qword[rdx + WORD_SIZE*rcx], r10
      dec rcx
      cmp rcx, 0
      jne lambdaEnv16 
;; jmp lambdaEnv16 
    lambdaEnvEnd16:

    ;;NOW WE TRY TO COPY PARAMS IF EXIST
      mov rcx,qword[rbp + 3 * WORD_SIZE] ;;rcx holds the number of params
      cmp rcx, 0
      je lCopyParamsEnd16 

      mov rax, qword[rbp + 3 * WORD_SIZE]
      shl rax, 3
  ;;  cmp rcx, 0
;;  je lCopyParamsEnd16
      MALLOC rax, rax
  ;;MALLOC rax, WORD_SIZE * rcx ;;rax holds the address of the newly allocated array for params in extenv
      mov qword[rdx], rax

    lCopyParams16:
;;cmp rcx,0 
;;je lCopyParamsEnd16
      mov r10, PVAR(rcx - 1) 
      mov [rax+ 8*(rcx-1)], r10
      dec rcx
      cmp rcx,0
      jne lCopyParams16
;;jmp lCopyParams16
      
      lCopyParamsEnd16:
      MAKE_CLOSURE(rax, rdx, Lcode16)

      jmp Lcont16
Lcode16:

      push rbp
      mov rbp , rsp
        mov rax, const_tbl +23

push rax
mov rax, PVAR(0)

push rax
push 2

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*0]
;;APPLICTP IS HINNAAA
 CLOSURE_ENV rbx, rax              ; rbx = rax -> env 

      push rbx 
     
      ;; why plus one  
      push qword [rbp + WORD_SIZE * 1] 
 ;push the old ret addr as a ret address for h
   
      
  
    ;; mov r8, PVAR(-1)                   ; r8 = n (= PVAR(-1) = old args num)
    mov r8, [rbp + 3*WORD_SIZE]  
    ;; r8 holds the number of params of the A frame
    add r8, 3                       
    ;; r8 holds the size of the A frame --> number of params + the lexenv + #params pushed + return addr
    shl r8, 3                       
    ;;multiplied by 8 SO -->r8 now holds the number of bytes held by the A frame
    add r8, rbp                     
    ;;now r8 points to the last param(An-1) of the A frame

    mov rbp, PVAR(-4)                ; rbp points to old rbp
    ;;above line same as mov rbp, [rbp]

    mov rcx, [rsp + WORD_SIZE * 2]   
    ;; RCX HOLDS THE NUMBER OF ARGS IN THE B FRAME = List.length lst_str 
    add rcx, 3                       
    ;;rcx now holds the size of the new B frame --> M+3 -> #ARGS + LEX + RET-ADDR
    
    overwrite_frame17:
    
    mov r13, qword [rsp + WORD_SIZE * (rcx - 1)]
    mov r13, qword [rsp + WORD_SIZE * (rcx +1 -2)]
    mov [r8], qword r13
    ;;SINCE WE CANT COPY FROM ONE MEMORY ADDRESS TO ANOTHER WE USE THE R13 REGISTER AS AN AUXILARY MEMORY STORAGE

    sub r8, WORD_SIZE
    ;;WE SUB BY WORDS_SIZE SINCE R8 IS IN BYTES
    ;;now we move to the next cell of the stack
    dec rcx
    cmp rcx,0
    jne overwrite_frame17
  
    add r8, WORD_SIZE               
    ;; R8 HOLDS THE RETURN ADDRESS TO F 
    mov rsp, r8    
    ;;NOW WE HAVE UPDATED THE RSP -> STACK POINTER                

    ;;NOW JUMP TO CODE OF CLOSURE
    CLOSURE_CODE rax, rax            ; rax = rax -> code
    jmp rax
 
      leave
      ret
    Lcont16:

    leave
    ret
  Lcont15:

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	
mov qword[fvar_tbl + WORD_SIZE*38] , rax
    mov rax,SOB_VOID_ADDRESS

	call write_sob_if_not_void

;; APPLIC IS HINAAAA 
mov rax, qword [fvar_tbl + WORD_SIZE*24]

push rax
mov rax, qword [fvar_tbl + WORD_SIZE*21]

push rax
mov rax, qword [fvar_tbl + WORD_SIZE*2]

push rax

push 3
;; THE INITIAL ENVIRONMENT IS EMPTY SO THERE IS NOTHING TO COPY
    mov rdx, SOB_NIL_ADDRESS
    ;;NOW WE TRY TO COPY PARAMS IF EXIST
    mov rcx,qword[rbp + 3 * WORD_SIZE] ;;rcx holds the number of params
    cmp rcx, 0
    je lCopyParamsEnd18 ;;---> NO PARAMS TO COPY JUMP TO END

    mov rax, qword[rbp + 3 * WORD_SIZE]
    shl rax, 3
  ;;NOW RAX HOLDS THE NUMBER OF BYTES WE WANT TO ALLOCATE
  ;; cmp rcx, 0
;; je lCopyParamsEnd18
    MALLOC rax, rax
;;MALLOC rax, WORD_SIZE * rcx ;;rax holds the address of the newly allocated array for params in extenv
    mov qword[rdx], rax

  lCopyParams18:
;;cmp rcx,0 
;;je lCopyParamsEnd18
    mov r10, PVAR(rcx - 1) 
    mov [rax+ 8*(rcx-1)], r10
    dec rcx
    cmp rcx,0
    jne lCopyParams18
;;jmp lCopyParams18
    
    lCopyParamsEnd18:
    MAKE_CLOSURE(rax, rdx, Lcode18)

    jmp Lcont18
Lcode18:

    push rbp
    mov rbp , rsp
    ;;LAMBDA IS HIIINA

  ;;mov rdx, SOB_NIL_ADDRESS
;; mov rcx,1
;;cmp rcx , 0
;;je lambdaEnvEnd19

      mov rcx,1
      MALLOC rdx , WORD_SIZE * 2 ;;rdx points to extended env
      mov rbx, qword[rbp + WORD_SIZE*2] ;;point to lex env
    lambdaEnv19:
;;cmp rcx, 0
;; je lambdaEnvEnd19
      mov r10, qword[rbx + WORD_SIZE*(rcx-1)]
      mov qword[rdx + WORD_SIZE*rcx], r10
      dec rcx
      cmp rcx, 0
      jne lambdaEnv19 
;; jmp lambdaEnv19 
    lambdaEnvEnd19:

    ;;NOW WE TRY TO COPY PARAMS IF EXIST
      mov rcx,qword[rbp + 3 * WORD_SIZE] ;;rcx holds the number of params
      cmp rcx, 0
      je lCopyParamsEnd19 

      mov rax, qword[rbp + 3 * WORD_SIZE]
      shl rax, 3
  ;;  cmp rcx, 0
;;  je lCopyParamsEnd19
      MALLOC rax, rax
  ;;MALLOC rax, WORD_SIZE * rcx ;;rax holds the address of the newly allocated array for params in extenv
      mov qword[rdx], rax

    lCopyParams19:
;;cmp rcx,0 
;;je lCopyParamsEnd19
      mov r10, PVAR(rcx - 1) 
      mov [rax+ 8*(rcx-1)], r10
      dec rcx
      cmp rcx,0
      jne lCopyParams19
;;jmp lCopyParams19
      
      lCopyParamsEnd19:
      MAKE_CLOSURE(rax, rdx, Lcode19)

      jmp Lcont19
Lcode19:

      push rbp
      mov rbp , rsp
      ;;IF HEEEEEEERE 
;; APPLIC IS HINAAAA 
mov rax, PVAR(0)

push rax

push 1

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*0]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	
cmp rax, SOB_FALSE_ADDRESS
        je Lelse20
  mov rax, const_tbl +40

push rax
;; APPLIC IS HINAAAA 
mov rax, PVAR(0)

push rax

push 1

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*2]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

push rax
push 2

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*1]
;;APPLICTP IS HINNAAA
 CLOSURE_ENV rbx, rax              ; rbx = rax -> env 

      push rbx 
     
      ;; why plus one  
      push qword [rbp + WORD_SIZE * 1] 
 ;push the old ret addr as a ret address for h
   
      
  
    ;; mov r8, PVAR(-1)                   ; r8 = n (= PVAR(-1) = old args num)
    mov r8, [rbp + 3*WORD_SIZE]  
    ;; r8 holds the number of params of the A frame
    add r8, 3                       
    ;; r8 holds the size of the A frame --> number of params + the lexenv + #params pushed + return addr
    shl r8, 3                       
    ;;multiplied by 8 SO -->r8 now holds the number of bytes held by the A frame
    add r8, rbp                     
    ;;now r8 points to the last param(An-1) of the A frame

    mov rbp, PVAR(-4)                ; rbp points to old rbp
    ;;above line same as mov rbp, [rbp]

    mov rcx, [rsp + WORD_SIZE * 2]   
    ;; RCX HOLDS THE NUMBER OF ARGS IN THE B FRAME = List.length lst_str 
    add rcx, 3                       
    ;;rcx now holds the size of the new B frame --> M+3 -> #ARGS + LEX + RET-ADDR
    
    overwrite_frame21:
    
    mov r13, qword [rsp + WORD_SIZE * (rcx - 1)]
    mov r13, qword [rsp + WORD_SIZE * (rcx +1 -2)]
    mov [r8], qword r13
    ;;SINCE WE CANT COPY FROM ONE MEMORY ADDRESS TO ANOTHER WE USE THE R13 REGISTER AS AN AUXILARY MEMORY STORAGE

    sub r8, WORD_SIZE
    ;;WE SUB BY WORDS_SIZE SINCE R8 IS IN BYTES
    ;;now we move to the next cell of the stack
    dec rcx
    cmp rcx,0
    jne overwrite_frame21
  
    add r8, WORD_SIZE               
    ;; R8 HOLDS THE RETURN ADDRESS TO F 
    mov rsp, r8    
    ;;NOW WE HAVE UPDATED THE RSP -> STACK POINTER                

    ;;NOW JUMP TO CODE OF CLOSURE
    CLOSURE_CODE rax, rax            ; rax = rax -> code
    jmp rax
 jmp Lexit20
        Lelse20:
  mov rax, const_tbl +2

Lexit20:

      leave
      ret
    Lcont19:

    leave
    ret
  Lcont18:

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	
mov qword[fvar_tbl + WORD_SIZE*39] , rax
    mov rax,SOB_VOID_ADDRESS

	call write_sob_if_not_void

;; APPLIC IS HINAAAA 
mov rax, qword [fvar_tbl + WORD_SIZE*2]

push rax
mov rax, qword [fvar_tbl + WORD_SIZE*1]

push rax

push 2
;; THE INITIAL ENVIRONMENT IS EMPTY SO THERE IS NOTHING TO COPY
    mov rdx, SOB_NIL_ADDRESS
    ;;NOW WE TRY TO COPY PARAMS IF EXIST
    mov rcx,qword[rbp + 3 * WORD_SIZE] ;;rcx holds the number of params
    cmp rcx, 0
    je lCopyParamsEnd22 ;;---> NO PARAMS TO COPY JUMP TO END

    mov rax, qword[rbp + 3 * WORD_SIZE]
    shl rax, 3
  ;;NOW RAX HOLDS THE NUMBER OF BYTES WE WANT TO ALLOCATE
  ;; cmp rcx, 0
;; je lCopyParamsEnd22
    MALLOC rax, rax
;;MALLOC rax, WORD_SIZE * rcx ;;rax holds the address of the newly allocated array for params in extenv
    mov qword[rdx], rax

  lCopyParams22:
;;cmp rcx,0 
;;je lCopyParamsEnd22
    mov r10, PVAR(rcx - 1) 
    mov [rax+ 8*(rcx-1)], r10
    dec rcx
    cmp rcx,0
    jne lCopyParams22
;;jmp lCopyParams22
    
    lCopyParamsEnd22:
    MAKE_CLOSURE(rax, rdx, Lcode22)

    jmp Lcont22
Lcode22:

    push rbp
    mov rbp , rsp
    ;;LAMBDA IS HIIINA

  ;;mov rdx, SOB_NIL_ADDRESS
;; mov rcx,1
;;cmp rcx , 0
;;je lambdaEnvEnd23

      mov rcx,1
      MALLOC rdx , WORD_SIZE * 2 ;;rdx points to extended env
      mov rbx, qword[rbp + WORD_SIZE*2] ;;point to lex env
    lambdaEnv23:
;;cmp rcx, 0
;; je lambdaEnvEnd23
      mov r10, qword[rbx + WORD_SIZE*(rcx-1)]
      mov qword[rdx + WORD_SIZE*rcx], r10
      dec rcx
      cmp rcx, 0
      jne lambdaEnv23 
;; jmp lambdaEnv23 
    lambdaEnvEnd23:

    ;;NOW WE TRY TO COPY PARAMS IF EXIST
      mov rcx,qword[rbp + 3 * WORD_SIZE] ;;rcx holds the number of params
      cmp rcx, 0
      je lCopyParamsEnd23 

      mov rax, qword[rbp + 3 * WORD_SIZE]
      shl rax, 3
  ;;  cmp rcx, 0
;;  je lCopyParamsEnd23
      MALLOC rax, rax
  ;;MALLOC rax, WORD_SIZE * rcx ;;rax holds the address of the newly allocated array for params in extenv
      mov qword[rdx], rax

    lCopyParams23:
;;cmp rcx,0 
;;je lCopyParamsEnd23
      mov r10, PVAR(rcx - 1) 
      mov [rax+ 8*(rcx-1)], r10
      dec rcx
      cmp rcx,0
      jne lCopyParams23
;;jmp lCopyParams23
      
      lCopyParamsEnd23:
      MAKE_CLOSURE(rax, rdx, Lcode23)

      jmp Lcont23
Lcode23:

      push rbp
      mov rbp , rsp
      ;; APPLIC IS HINAAAA 
mov rax, PVAR(0)

push rax

push 1

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*0]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	
cmp rax, SOB_FALSE_ADDRESS
        jne Lexit24
mov rax, PVAR(0)

push rax
push 1

    mov rax ,qword[rbp + WORD_SIZE*2]
    mov rax ,qword[rax + WORD_SIZE*0]
    mov rax, qword[rax + WORD_SIZE*1]
;;APPLICTP IS HINNAAA
 CLOSURE_ENV rbx, rax              ; rbx = rax -> env 

      push rbx 
     
      ;; why plus one  
      push qword [rbp + WORD_SIZE * 1] 
 ;push the old ret addr as a ret address for h
   
      
  
    ;; mov r8, PVAR(-1)                   ; r8 = n (= PVAR(-1) = old args num)
    mov r8, [rbp + 3*WORD_SIZE]  
    ;; r8 holds the number of params of the A frame
    add r8, 3                       
    ;; r8 holds the size of the A frame --> number of params + the lexenv + #params pushed + return addr
    shl r8, 3                       
    ;;multiplied by 8 SO -->r8 now holds the number of bytes held by the A frame
    add r8, rbp                     
    ;;now r8 points to the last param(An-1) of the A frame

    mov rbp, PVAR(-4)                ; rbp points to old rbp
    ;;above line same as mov rbp, [rbp]

    mov rcx, [rsp + WORD_SIZE * 2]   
    ;; RCX HOLDS THE NUMBER OF ARGS IN THE B FRAME = List.length lst_str 
    add rcx, 3                       
    ;;rcx now holds the size of the new B frame --> M+3 -> #ARGS + LEX + RET-ADDR
    
    overwrite_frame25:
    
    mov r13, qword [rsp + WORD_SIZE * (rcx - 1)]
    mov r13, qword [rsp + WORD_SIZE * (rcx +1 -2)]
    mov [r8], qword r13
    ;;SINCE WE CANT COPY FROM ONE MEMORY ADDRESS TO ANOTHER WE USE THE R13 REGISTER AS AN AUXILARY MEMORY STORAGE

    sub r8, WORD_SIZE
    ;;WE SUB BY WORDS_SIZE SINCE R8 IS IN BYTES
    ;;now we move to the next cell of the stack
    dec rcx
    cmp rcx,0
    jne overwrite_frame25
  
    add r8, WORD_SIZE               
    ;; R8 HOLDS THE RETURN ADDRESS TO F 
    mov rsp, r8    
    ;;NOW WE HAVE UPDATED THE RSP -> STACK POINTER                

    ;;NOW JUMP TO CODE OF CLOSURE
    CLOSURE_CODE rax, rax            ; rax = rax -> code
    jmp rax
 Lexit24:

      leave
      ret
    Lcont23:

    leave
    ret
  Lcont22:

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	
mov qword[fvar_tbl + WORD_SIZE*40] , rax
    mov rax,SOB_VOID_ADDRESS

	call write_sob_if_not_void

;; APPLIC IS HINAAAA 
  mov rax, const_tbl +40

push rax
  mov rax, const_tbl +57

push rax

push 2
mov rax, qword [fvar_tbl + WORD_SIZE*37]

 
      CLOSURE_ENV rbx, rax 

      ;; RBX HOLDS THE ADDRESS OF THE ENV OF THE CLOSURE POINTED TO BY RAX REGITER 

     
      push rbx

      ;; WE PUSH THE RBX SO THAT WE DONT OVERRIDE THE RBX REGISTER THAT POINTS TO THE CLOSURE ENV

	

      CLOSURE_CODE rdx, rax     
      ;; RDX POINTS TO THE CODE OF THE CURRENT CLOSURE


      call rdx 

    ;; NOW WE CALLED THE BODY OF THE CLOSURE   
	
              
      ;; TAKE CARE OF THE STACK --> clean the stack
      add rsp, WORD_SIZE * 1    
      pop rbx                  
      shl rbx, 3               
      add rsp, rbx 
	

	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CAR rax, rsi
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov [rsi+1], rdi
         mov rax, SOB_VOID_ADDRESS
         
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CDR rax, rsi
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov [rsi+9], rdi
         mov rax, SOB_VOID_ADDRESS
        
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR(rax, rsi, rdi)
         pop rbp
         ret

apply:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	
        mov rbx, [rbp + 8*3]
        mov rax, [rbp + 8*6]
       ;;THE SECOND ARGUMENT IS THE LIST WE WANT TO APPLY THE FUNCTION TO
        ARGSIZE   
        cmp rax, 0
        jne .emptylist

      ;;THE LIST IS NOT NOT EMPTY
      ;;START OF HANDLING THE PARAMS IN THE LIST OF THE APPLY FUNCTION************************************
        mov rbx, [rbp + 8*3]
        add rbx, 3

      ;;HERE WE SHIFT THE STACK IN ORDER TO PREPARE IT FOR THE APPLIED FUNCTION
        .shiftingTheParams:
               dec rbx
               mov rcx ,[rbp + 8 *(rbx)]
               mov [rbp + 8*(rbx+1)], rcx
               cmp rbx, 0
               jne .shiftingTheParams
      ;; END OF DEALING WITH THE LIST OF PARAMS OF THE APPLY FUNCTION


        pop rbx
        sub qword [rbp + 8*3], 1
         jmp .applyfunction
        ;;AT THIS POINT WE

        .emptylist:
          mov rcx, rax
          dec rcx
           mov rdx, 0
          mov rsi, rbx
          add rsi,3


      ;;vvvvvSTART MOVING THE FOLLWINGvvvvvv
           .moveTheFollowing:
           dec rsi
           mov rax, [rbp + 8*(rdx)]
           mov rbx, rdx
           sub rbx, rcx
           inc rdx
           mov [rbp + 8*(rbx)], rax
           cmp rsi, 0
           jne .moveTheFollowing
    ;;^^^^^^^^^FINISHE THE MOVING^^^^^^^^^^^^ 


          ;;vvvvNOW WE LOAD THE SIZE TO THE RAX REGISTERvvv
          mov rax,rcx
          shl rax,3
          ;;^^^SHIFT BY 3 IS THE SAME AS MUL BY 8 IN ORDER TO GET THE BYTES SIZE^^^
           sub rsp, rax
       
           mov rax, [rsp + 8*3]
           lea rbx, [rsp+8*(3+rax)]
           add rax, rcx
           mov [rsp + 8*3], rax
           mov rax, [rsp + 8*(3+rax)]  
          ;;RAX WILL ALWAYS POINT AT THE CURRENT PAIR
       
       
        ;; vvvvvvvvMAKE THE LIST PARAMS AS THE FUNCTION PARAMSvvvvvvv
        .loadListAsParams:
           CAR rcx, rax
           CDR rax, rax
           mov [rbx], rcx
           add rbx, 8
           cmp rax, SOB_NIL_ADDRESS
           jne .loadListAsParams
      ;;^^^^^^
          
        ;;WE PREPARE THE STACK FOR THE APPLICATION
      ;; OF THE FUNCTION ON THE PARAMS OF THE LIST AS ITS OWN PARAMS
    
        .applyfunction:
      ;;vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
          mov rax, [rbp + 8*4]
        ;;NOW RAX POINTS TO THE FUNCTION WE WANT TO APPLY

          mov rcx, 3
         .myshift:
          mov rbx,[rbp + 8*rcx]
          mov [rbp + 8*(rcx+1)], rbx
          loop .myshift
      ;;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

      ;;THE STACK HAS BEEN SHIFTED TO MATCH THE APPLICATION OF THE FUNCTION APPLIED
           add rsp, 8
           sub qword[rbp +8*4], 1
           CLOSURE_ENV rbx, rax
           mov [rbp + 8*3], rbx
           CLOSURE_CODE rbx, rax
          ;;RBX HOLDS THE ADDRESS POINTING AT THE START OF THE APPLIED FUNCTION
           pop rbp
           jmp rbx
                
                
         pop rbp
         ret